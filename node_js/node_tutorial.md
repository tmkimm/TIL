# Node.js란?

Node.js는 크롬 V8 엔진으로 빌드된 자바스크립트 런타임입니다.
Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다.
서버로만 사용되는것이 아닙니다.

---

## 자바스크립트 런타임

노드는 V8과 더불어 libuv라는 라이브러리를 사용합니다.

V8과 libuv는 C와 C++로 구현되어 있습니다.

작성한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해주므로 C와 C++은 몰라도 됩니다.

---

## 이벤트 기반

이벤트 기반이란 이벤트가 발생할때 미리 지정해둔 작업을 수행하는 방식을 의미합니다.

이것을 이벤트 리스너에 콜백 함수를 등록한다고 표현합니다.

이벤트 기반 모델에서는 **이벤트 루프**라는 개념이 등장합니다. 여러 이벤트가 동시에 발생했을때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.

**이벤트 루프?**

아래의 코드에서, 결과는 다음과 같습니다.

```jsx
function run() {
  console.log("3초 뒤 실행");
}

console.log("시작");
setTimeOut(run, 3000);
console.log("끝");

/*
시작
끝
3초 후 실행
*/
```

실행 결과는 쉽게 예측할 수 있지만 호출 스택으로 설명하기는 힘듭니다.

setTimeOut의 콜백인 run이 호출 스택에 언제 들어가는지 알기 어렵기 때문입니다.

이를 이해하기 위해서는 이벤트 루프, 테스크 큐, 백그라운드를 알아야합니다.

1. setTimeOut이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고 호출 스택으로 빠집니다.
2. 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보냅니다.
3. 호출 스택 실행이 끝나 비워지면
4. 이벤트 루프가 태스크 큐의 콜백(run)을 호출 스택으로 올립니다.
5. 이후 이벤트 루프는 태스크 큐에 콜백이 들어올때까지 대기합니다.

> 여기서 하나 알아둬야될 부분은 3. 호출 스택 실행이 비워지지 않으면 이벤트 루프는 콜백을 호출 스택으로 올리지 않습니다.

따라서 setTimeOut의 실행 시간이 정확하지 않을 수도 있습니다.

- 이벤트 루프 : 이벤트 발생 시 콜백 함수를 관리하고 호출된 콜백 함수의 실행 순서를 결정합니다.
- 태스크 큐 : 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간입니다. 콜백들이 이벤트 루프가 정한 순서대로 줄을 서있으므로 콜백 큐라도고 불립니다.
- 백그라운드: 타이머나 i/o작업 콜백 또는 이벤트 리스너들이 대기하는 곳입니다.

---

## 논블록킹 I/O

논블로킹이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻합니다.

블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간동안 처리할 수 있음을 알 수 있습니다.

하지만 싱글 스레드라는 한계때문에 자바스크립트의 모든 코드가 이 방식으로 시간적 이득을 볼 수 있는 것은 아닙니다.

파일 시스템 접근이나 네트워크 요청같은 I/O작업이 주로 시간적 이득을 많이 봅니다.

동기와 블로킹이 유사하고, 비동기와 논블로킹이 유사합니다.

---

## 싱글 스레드

노드는 싱글스레드 이므로 주어진 작업을 혼자서 처리해야 합니다.

반대로 멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있습니다.

JS와 노드에서 논블로킹이 중요한 이유는 싱글 스레드이기 때문입니다.

한 요청에 대한 처리가 끝날때까지 기다리는 것이 아니라, 요청이 왔다는 것만 알려주고 완료되는대로 응답을 해줍니다.

하지만 싱글 스레드가 잘못될 경우 처리를 해줄 사람이 없으므로 큰 문제가 발생할 수 있습니다.

여기까지만 보았을때는 당연히 멀티 스레드가 좋은 것 같지만 각자의 장단점이 있습니다.

스레드를 늘리면 되므로 요청과 응답에는 문제가 없지만 요청이 늘어날 경우 스레드도 늘어나게 되고 관리하는 과정에서 비용이 발생합니다.

---

### 멀티 스레드 - 논블로킹 방식으로 처리하면 안될까?

그렇다면 멀티 스레드가 모두 논블로킹 방식으로 처리하면 더 좋지 않을까 하는 의문이 들 수 있습니다. 실제로 그렇습니다. 노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있습니다. 하지만 엄밀히 말하면 멀티 스레딩보다 멀티 프로세싱에 가깝습니다.

- 프로세스 : 운영체제에서 할당하는 작업의 단위입니다. 노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스입니다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 하나의 프로세스는 여러개의 스레드를 가질 수 있으며 자원을 공유합니다.

사실 노드 프로세스는 내부적으로 스레드를 여러개 가지고 있습니다. 하지만 우리가 직접 제어할 수 있는 스레드는 하나이므로 흔히 싱글 스레드라고 부르는 것입니다.

노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했습니다. js 언어 자체가 싱글 스레드 특성을 띄고 있기 때문입니다.

cluster 모듈과 pm2 패키지를 이용하여 멀티 프로세싱을 가능하게 할 수 있습니다.

---

## 서버로서의 노드

노드 서버의 장점은 싱글 스레드, 논블로킹 모델의 장단점

싱글 스레드여서 멀티 스레드 방식보다는 컴퓨터의 자원을 적게 사용한다는 장점이 있지만 cpu 코어를 하나밖에 사용하지 못하는 단점도 있습니다.

> 간단 정리

1. global 객체는 window와 같은 전역 객체. 모든 파일에서 접근 수 있고 생략할 수 있다.
→ 노드에는 DOM이나 BOM이 없어 window와 document 객체를 사용할 수 없다!
2. 우리 노드는 웹 브라우저에서 사용되는 자바스크립트보다 더 많은 기능을 제공합니다.
운영체제 정보에 접근할수도 있고, 클라이언트가 요청하는 주소에 대한 정보도 가져올 수 있습니다. 노드에서 제공되는 모듈을 사용하면 됩니다.
실행되는 파일명, 폴더명 → __filename, __dirname
아키텍처 정보, 운영플랫폼 정보, pid 등 → process 객체 
운영체제 정보 - os 모듈
폴더와파일 경로 쉽게 조작 - path 모듈(os별로 경로 구분자가 다르기때문에 사용)
파일 시스템 조작 - fs 모듈(buffer 모듈 같이 사용)
인터넷 주소 조작 - url 모듈
url에서 search 부분 조작 - querystring 모듈
암호화 - crypto 모듈
이벤트 - events 모듈
3. 예외 처리 - try catch로 감싸줘야함
process 객체에 uncaughtException 이벤트를 붙여주면 프로세스가 멈추지 않고 에러를 감지하지만 노드 공식 문서에서는 최후의 수단으로 사용하라고 말함. 그 이후 프로세스가 제대로 동작하는지 보증하지 않음.